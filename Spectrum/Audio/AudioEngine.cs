using System;
using System.Collections.Generic;
using System.Linq;
using OpenAL;
using static Spectrum.InternalLog;

namespace Spectrum.Audio
{
	// Controller for the OpenAL context and other objects, and the lifetime of the audio system
	internal static class AudioEngine
	{
		// Reasonable limit, since OpenAL Soft *technically* supports infinite sources as a software implementation
		// Nobody should need anything higher than this, and too many sources would slow it down
		// We can do testing in the future to get a better estimate for what this value should be
		public const int MAX_SOURCE_COUNT = 24;

		#region Fields
		// The OpenAL device handle
		public static IntPtr Device { get; private set; } = IntPtr.Zero;
		// The OpenAL context
		internal static IntPtr Context { get; private set; } = IntPtr.Zero;

		// Audio sources
		private static readonly uint[] s_allSources = new uint[MAX_SOURCE_COUNT]; // All sources generated by the system
		private static readonly Stack<uint> s_availableSources = new Stack<uint>(MAX_SOURCE_COUNT); // Sources available for binding
		private static readonly List<uint> s_usedSources = new List<uint>(MAX_SOURCE_COUNT); // Sources currently bound
		private static readonly object s_sourceLock = new object(); // Object for thread-safe access to sources

		// Gets if the engine is shutdown (affects how other audio objects finalize)
		public static bool IsShutdown { get; private set; } = false;
		#endregion // Fields

		public static void Initialize()
		{
			// Populate the device lists
			PlaybackDevice.PopulateDeviceList();
			if (PlaybackDevice.Devices.Count == 0)
				throw new AudioException("There are no audio playback devices available");
			LDEBUG($"Available audio playback devices: {String.Join(", ", PlaybackDevice.Devices.Select(d => d.Identifier))}.");

			// Open the default playback device
			Device = ALC10.alcOpenDevice(PlaybackDevice.Devices[0].Identifier);
			ALUtils.CheckALCError();
			if (Device == IntPtr.Zero)
				throw new AudioException("Unable to open default audio playback device");

			// Create the al context and set it as active
			Context = ALC10.alcCreateContext(Device, new int[2] { 0, 0 }); // Two 0s tell OpenAL no special attribs
			ALUtils.CheckALCError();
			if (Context == IntPtr.Zero)
				throw new AudioException("Unable to create audio context");
			ALC10.alcMakeContextCurrent(Context);
			ALUtils.CheckALCError();

			// Generate audio sources
			AL10.alGenSources(MAX_SOURCE_COUNT, s_allSources);
			ALUtils.CheckALError("unable to generate audio sources");
			foreach (var src in s_allSources)
				s_availableSources.Push(src);

			// Report
			LINFO("Started OpenAL audio engine.");
			LINFO($"    Device: {PlaybackDevice.Devices[0].Identifier}.");
		}

		public static void Shutdown()
		{
			// Destroy the sources
			AL10.alDeleteSources(MAX_SOURCE_COUNT, s_allSources);
			ALUtils.CheckALError("unable to free audio sources");
			s_availableSources.Clear();
			s_usedSources.Clear();

			// Destroy the context, and then close the device
			ALC10.alcMakeContextCurrent(IntPtr.Zero);
			ALUtils.CheckALCError();
			ALC10.alcDestroyContext(Context);
			ALUtils.CheckALCError();
			Context = IntPtr.Zero;
			ALC10.alcCloseDevice(Device);
			ALUtils.CheckALCError();
			Device = IntPtr.Zero;

			IsShutdown = true;

			// Report
			LINFO("Shutdown OpenAL audio engine.");
		}

		public static void Update()
		{

		}

		public static uint ReserveSource()
		{
			lock (s_sourceLock)
			{
				if (s_availableSources.Count == 0)
					throw new AudioPlayLimitException();

				uint src = s_availableSources.Pop();
				s_usedSources.Add(src);
				return src;	
			}
		}

		public static void ReleaseSource(uint src)
		{
			lock (s_sourceLock)
			{
				s_usedSources.Remove(src);
				s_availableSources.Push(src);
			}
		}
	}

	/// <summary>
	/// Exception thrown when the audio engine encounters an unrecoverable error.
	/// </summary>
	public class AudioException : Exception
	{
		internal AudioException(string message) :
			base(message)
		{ }

		internal AudioException(string message, Exception innerException) :
			base(message, innerException)
		{ }
	}

	/// <summary>
	/// Exception thrown when too many audio sources are requested.
	/// </summary>
	public class AudioPlayLimitException : AudioException
	{
		internal AudioPlayLimitException() :
			base($"The maximum number of audio sources ({AudioEngine.MAX_SOURCE_COUNT}) has been reached")
		{ }
	}
}
