using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Spectrum.Content
{
	// Contains information and references loaded from a .cpak file generated by Prism
	// Also caches content packs to speed up pointing more than one content manager at the same pack file
	internal class ContentPack
	{
		public static readonly string FILE_EXTENSION = ".cpak";
		public static readonly string DEBUG_EXTENSION = ".dci";

		private static readonly Dictionary<string, ContentPack> s_packCache = 
			new Dictionary<string, ContentPack>();

		#region Fields
		// Build information
		public readonly bool ReleaseMode;
		public readonly uint PackSize;
		public readonly uint Timestamp;

		// Dictionary of loader hashes and their instances
		private readonly Dictionary<uint, LoaderType> _loaders;
		public IReadOnlyDictionary<uint, LoaderType> Loaders => _loaders;

		// Bin files (will only exist for release built content)
		private readonly BinFile[] _binFiles;
		public IReadOnlyList<BinFile> BinFiles => _binFiles;

		// The map of content items names to bin files and bin indices
		private readonly Dictionary<string, (uint BinNum, uint Index)> _itemMap;
		public IReadOnlyDictionary<string, (uint BinNum, uint Index)> ItemMap => _itemMap;

		// The path info for this file (absolute paths)
		public readonly string FilePath;
		public readonly string Directory;
		#endregion // Fields

		private ContentPack(string path, BinaryReader reader)
		{
			// Calculate the path info
			FilePath = path;
			Directory = Path.GetDirectoryName(path);

			// Validate the header
			var header = reader.ReadBytes(5);
			if (header[0] != 'C' || header[1] != 'P' || header[2] != 'A' || header[3] != 'K' || header[4] != 1)
				throw new Exception("invalid header.");

			// Build flags
			byte flags = reader.ReadByte();
			ReleaseMode = (flags & 0x01) > 0;

			// Other build info
			PackSize = reader.ReadUInt32();
			Timestamp = reader.ReadUInt32();

			// Load the hash/name loader map
			uint lcount = reader.ReadUInt32();
			var loaders = new List<(uint Hash, string Name)>((int)lcount);
			for (uint i = 0; i < lcount; ++i)
			{
				var lname = reader.ReadString();
				var lhash = reader.ReadUInt32();
				loaders.Add((lhash, lname));
			}

			// Get the loader types
			_loaders = new Dictionary<uint, LoaderType>();
			foreach (var lpair in loaders)
			{
				var ltype = LoaderCache.GetOrLoad(lpair.Name);
				_loaders.Add(lpair.Hash, ltype);
			}

			// Load the bin files (if release)
			if (ReleaseMode)
			{
				uint bcount = reader.ReadUInt32();
				_binFiles = new BinFile[bcount];
				for (uint i = 0; i < bcount; ++i)
					_binFiles[i] = BinFile.LoadFromStream(i, Directory, Timestamp, reader);

				// Create the mapping
				_itemMap = new Dictionary<string, (uint BinNum, uint Index)>(_binFiles.Sum(bf => bf.Items.Count));
				for (int bi = 0; bi < _binFiles.Length; ++bi)
				{
					var bf = _binFiles[bi];
					uint ii = 0;
					foreach (var item in bf.Items)
						_itemMap.Add(item.Name, ((uint)bi, ii++));
				}
			}
			else
			{
				_binFiles = null;
				_itemMap = null;
			}
		}

		public bool TryGetItem(string name, out uint binNum, out BinEntry item)
		{
			if (_itemMap.ContainsKey(name))
			{
				var map = _itemMap[name];
				binNum = map.BinNum;
				item = _binFiles[map.BinNum].Items[(int)map.Index];
				return true;
			}
			else
			{
				item = default;
				binNum = UInt32.MaxValue;
				return false;
			}
		}

		public string GetDebugItemPath(string name) => Path.Combine(Directory, $"{name}{DEBUG_EXTENSION}");

		// If there is a content pack loaded at the path, return the cached instance, otherwise load and cache a new one
		public static ContentPack GetOrLoad(string path)
		{
			path = Path.GetFullPath(path);

			// Try to get it from the cache
			if (s_packCache.ContainsKey(path))
				return s_packCache[path];

			// Load a new one
			if (!File.Exists(path))
				throw new ContentException($"The content pack file '{path}' does not exist.");

			// Perform the load
			try
			{
				using (var reader = new BinaryReader(File.Open(path, FileMode.Open, FileAccess.Read, FileShare.None)))
				{
					var pack = new ContentPack(path, reader);
					s_packCache.Add(path, pack);
					return pack;
				}
			}
			catch (ContentException) { throw; }
			catch (Exception e)
			{
				throw new ContentException($"Unable to load the content pack file '{path}', reason: {e.Message}", e);
			}
		}
	}
}
