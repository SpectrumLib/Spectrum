/*
 * Microsoft Public License (Ms-PL) - Copyright (c) 2018-2020 The Spectrum Team
 * This file is subject to the terms and conditions of the Microsoft Public License, the text of which can be found in
 * the 'LICENSE' file at the root of this repository, or online at <https://opensource.org/licenses/MS-PL>.
 */
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Spectrum.Content
{
	// Contains content file metadata loaded from a .cpak file generated by Prism
	// Also caches objects, such as loader types, that are required by the pack file
	internal class ContentPack
	{
		private static readonly byte[] HEADER = Encoding.ASCII.GetBytes("CPAK");
		private const byte VERSION = 1;
		public static readonly string FILE_EXTENSION = ".cpak";

		private static readonly Dictionary<string, ContentPack> _PackCache =
			new Dictionary<string, ContentPack>();

		#region Fields
		// Pack file info
		public readonly FileInfo FileInfo;
		public readonly bool Release;
		public readonly bool HighCompression;
		public readonly DateTime Timestamp;

		public DirectoryInfo Directory => FileInfo.Directory;

		// The map of content items names to bin files and bin indices
		private readonly Dictionary<string, Entry> _entries;
		public IReadOnlyDictionary<string, Entry> Entries => _entries;
		#endregion // Fields

		private ContentPack(FileInfo info, BinaryReader reader)
		{
			FileInfo = info;

			// Header/Version/Flags
			Span<byte> header = stackalloc byte[6];
			reader.Read(header);
			if (!header.Slice(0, 4).SequenceEqual(HEADER.AsSpan()))
				throw new ContentException("Invalid content pack header");
			if (header[4] != VERSION)
				throw new ContentException("Content pack version mismatch");

			// Build flags & timestamp
			Release = (header[5] & 0x01) > 0;
			HighCompression = (header[5] & 0x04) > 0;
			Timestamp = DateTime.FromBinary(reader.ReadInt64());

			// Load the items
			int icnt = (int)reader.ReadUInt32();
			_entries = new Dictionary<string, Entry>(icnt);
			for (int i = 0; i < icnt; ++i)
			{
				var entry = new Entry {
					Name = reader.ReadString(),
					Type = reader.ReadString(),
					DataSize = reader.ReadUInt64(),
					BinSize = reader.ReadUInt64(),
					Compress = reader.ReadBoolean(),
					Offset = reader.ReadUInt64(),
					BinIndex = reader.ReadUInt32()
				};
				_entries.Add(entry.Name, entry);
			}
		}

		// Attempts to get the BinEntry information for a content item
		public bool TryGetItem(string name, out Entry item) => _entries.TryGetValue(name, out item);

		// If there is a content pack loaded at the path, return the cached instance, otherwise load and cache a new one
		public static ContentPack GetOrLoad(string path)
		{
			if (!PathUtils.TryMakeAbsolutePath(path, null, out var fullPath))
				throw new ContentException($"Invalid path '{path}'.");

			// Try to get it from the cache
			if (_PackCache.ContainsKey(fullPath))
				return _PackCache[fullPath];

			// Load a new one
			if (PathUtils.TryGetFileInfo(fullPath, out var finfo) || !finfo.Exists)
				throw new ContentException($"Content pack file '{fullPath}' does not exist.");

			// Perform the load
			try
			{
				using var reader = new BinaryReader(finfo.Open(FileMode.Open, FileAccess.Read, FileShare.None));
				_PackCache.Add(fullPath, new ContentPack(finfo, reader));
				return _PackCache[fullPath];
			}
			catch (ContentException) { throw; }
			catch (Exception e)
			{
				throw new ContentException($"Content pack load failed, reason: {e.Message}", e);
			}
		}

		// Contains a single content item entry from the cpak file
		public sealed class Entry
		{
			public string Name;	    // Name of the item
			public string Type;	    // Content type
			public ulong DataSize;  // Uncompressed full size
			public ulong BinSize;   // Compressed size
			public bool Compress;   // If the data is compressed
			public ulong Offset;    // Offset of the item into the bin file
			public uint BinIndex;   // Bin file index for the item (release only)
		}
	}
}
