using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Spectrum.Content
{
	// Contains information and references loaded from a .cpak file generated by Prism
	// Also caches content packs to speed up pointing more than one content manager at the same pack file
	internal class ContentPack
	{
		private static readonly Dictionary<string, ContentPack> s_packCache = 
			new Dictionary<string, ContentPack>();

		#region Fields
		// Build information
		public readonly bool ReleaseMode;
		public readonly bool Compressed;
		public readonly uint PackSize;
		public readonly uint Timestamp;

		// Dictionary of loader hashes and their instances
		private readonly Dictionary<uint, IContentLoader> _loaders;
		public IReadOnlyDictionary<uint, IContentLoader> Loaders => _loaders;

		// Bin files (will only exist for release built content)
		private readonly BinFile[] _binFiles;
		public IReadOnlyList<BinFile> BinFiles => _binFiles;

		// The path info for this file (absolute paths)
		public readonly string FilePath;
		public readonly string Directory;
		#endregion // Fields

		private ContentPack(string path, BinaryReader reader)
		{
			// Calculate the path info
			FilePath = path;
			Directory = Path.GetDirectoryName(path);

			// Validate the header
			var header = reader.ReadBytes(5);
			if (header[0] != 'C' || header[1] != 'P' || header[2] != 'A' || header[3] != 'K' || header[4] != 1)
				throw new Exception("invalid header.");

			// Build flags
			byte flags = reader.ReadByte();
			ReleaseMode = (flags & 0x01) > 0;
			Compressed = (flags & 0x02) > 0;

			// Other build info
			PackSize = reader.ReadUInt32();
			Timestamp = reader.ReadUInt32();

			// Load the hash/name loader map
			uint lcount = reader.ReadUInt32();
			var loaders = new List<(uint Hash, string Name)>((int)lcount);
			for (uint i = 0; i < lcount; ++i)
			{
				var lname = reader.ReadString();
				var lhash = reader.ReadUInt32();
				loaders.Add((lhash, lname));
			}

			// Get the loader types
			_loaders = new Dictionary<uint, IContentLoader>();
			foreach (var lpair in loaders)
			{
				var ltype = LoaderCache.GetOrLoad(lpair.Name);
				_loaders.Add(lpair.Hash, ltype.CreateInstance());
			}

			// Load the bin files (if release)
			if (ReleaseMode)
			{
				uint bcount = reader.ReadUInt32();
				_binFiles = new BinFile[bcount];
				for (uint i = 0; i < bcount; ++i)
					_binFiles[i] = BinFile.LoadFromStream(i, Directory, Timestamp, reader);
			}
			else
				_binFiles = null;
		}

		// If there is a content pack loaded at the path, return the cached instance, otherwise load and cache a new one
		public static ContentPack LoadFromFile(string path)
		{
			path = Path.GetFullPath(path);

			// Try to get it from the cache
			if (s_packCache.ContainsKey(path))
				return s_packCache[path];

			// Load a new one
			if (!File.Exists(path))
				throw new ContentException($"The content pack file '{path}' does not exist.");

			// Perform the load
			try
			{
				using (var reader = new BinaryReader(File.Open(path, FileMode.Open, FileAccess.Read, FileShare.None)))
				{
					var pack = new ContentPack(path, reader);
					s_packCache.Add(path, pack);
					return pack;
				}
			}
			catch (ContentException) { throw; }
			catch (Exception e)
			{
				throw new ContentException($"Unable to load the content pack file '{path}', reason: {e.Message}", e);
			}
		}
	}
}
